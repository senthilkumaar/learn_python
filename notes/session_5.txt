Summary:
  1. Comprehensions
    a. List Comprehensions
    b. Dictionary Comprehensions
    c. Set comprehension

  2. Lambda Functions
      a. Callback Functions
      b. lambda function definition
      c. Sorting dictionary by value


Comprehensions in Python provide us with a short and concise way to construct new sequences (such as lists, set, dictionary etc.) using sequences which have been already defined. Python supports the following 4 types of comprehensions:
    List Comprehensions
    Dictionary Comprehensions
    Set Comprehensions

List comprehension

Usual way:
    new_list = []
    for i in old_list:
        new_list.append(expressions(i))

Comprehension way:

    new_list = [expression for item in list]
    output_list = [output_exp for var in input_list if (var satisfies this condition)]

# simple example
x = [i for i in range(10)]

# Comprehension to create even squares
new_range  = [i * i for i in range(5) if i % 2 == 0]


# Write a list comprehension to return a list of strings printed two times each
alphabets = ['a', 'b', 'c']
s_twice = [2 * alphabet for alphabet in alphabets]
print(s_twice)
['aa', 'bb', 'cc']

# List comprehension with conditionals

      Syntax:
          new_list = [expression for item in list if condition]

# Write a list comprehension to create a list of lower case words from a list
list_of_str = ['This', 'is', 'A', 'List', 'OF', 'STrings', 1000]
list_of_lower_str = [word.lower() for word in list_of_str ]  # error
list_of_lower_str = [ word.lower() for word in list_of_str if type(word) is str]


Dictionary comprehensions
    - Constructing a dictionary using comprehension is similar to list comprehension
    - Syntax:
        {key:value for i in list}
        output_dict = {key:value for (key, value) in iterable if (key, value satisfy this condition)}

# dict comprehension to create dict with numbers as values
{str(i):i for i in [1,2,3,4,5]}
{'1': 1, '3': 3, '2': 2, '5': 5, '4': 4}

# dict comprehension to create dict with number of times a word appears in a list
# Usual way:

cmd_history = ['ps -ef', 'subprocess', 'fork', 'fork', 'mkdir', 'ps -ef']  # input list
cmd_count = {}  # result dictionary
for cmd in cmd_history:
    cmd_count[cmd] = cmd_history.count(cmd)   # create key with cmd and value with count
# end for
print(cmd_count)

Comprehension:

{cmd: cmd_history.count(cmd) for cmd in cmd_history}


# Set comprehension
input_list = [1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 7]
output_set = set()

# Using loop for constructing output set
for var in input_list:
    if var % 2 == 0:
        output_set.add(var)


print("Output Set using for loop:", output_set)


# Comprehension way
input_list = [1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 7]

set_using_comp = {var for var in input_list if var % 2 == 0}

print("Output Set using set comprehensions:", set_using_comp)



2. Lambda functions

Questions:
    Why are functions first class objects?
    Write a lambda function that doubles and returns any number (data-type) passed to it
    How will you sort a dictionary by its value in reverse order? (and return as list of tuples)


# Callback functions
def add(n1, n2):
    return n1 + n2

add(1, 2)

def mul(n1, n2):
    return n1 * n2

def calculator(num1, num2, function):
    result = function(num1, num2)     # third arg function is called with first two args
    print(result)

def first_item(sequence):
    return sequence[0]

def second_item(sequence):
    return sequence[1]

d = {'messages': 1, 'requests': 2, 'notifs': 3}

def print_dict_item(dictionary, func=first_item):
    """ Prints the keys of each dictionary key-value pair"""
    dict_items = dictionary.items()    # key-value pair as List of tuples form

    for key_value_tuple in dict_items:
        key = func(key_value_tuple)
        print(key)


print_dict_item(d, func=second_item)
print_dict_item(d, func=second_item)


# Lambda functions
Lambda Expressions
   - Lambda functions can be used wherever function objects are required
   - They are restricted to a single expression

   Syntax:
       <function name> = lambda x [,y] [,z]: <expression>                # note: there is no return keyword

add_ten = lambda a : a + 10   # one argument
print(add_ten(5))

mail_id = lambda f_name, l_name, c_name: '{}.{}@{}.com'.format(f_name, l_name, c_name)
print(mail_id('john', 'doe', 'company'))


# Simple examples
average = lambda l: sum(l) / len(l) # calculate average of numbers in a list
average([10, 10, 10, 10])


# Sort dictionary by value
people_count_dict = {
    'hcl': 1000,
    'tcs': 1200,
    'cts': 650,
    'wipro': 700
}

# Normal sorting
sorted(people_count_dict)   # sorts company names in alphabetical order

# To sort by values
# 1. Use sorted() function on dict.items() -> list of tuples [(a, b), (c, d), ...]
# 2. Pass the keyword argument 'key' as the lambda function.
     lambda x: x[1]

sorted(people_count_dict.items(), key=lambda x: x[1])
sorted(people_count_dict.items(), key=lambda x: x[1], reverse=True)
